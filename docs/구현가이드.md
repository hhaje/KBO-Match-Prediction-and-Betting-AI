# KBO 경기 예측 AI 시스템 구현 가이드

## 📋 목차
1. [환경 설정](#1-환경-설정)
2. [데이터베이스 구축](#2-데이터베이스-구축)
3. [데이터 수집](#3-데이터-수집)
4. [ML 모델 개발](#4-ml-모델-개발)
5. [백엔드 API 개발](#5-백엔드-api-개발)
6. [프론트엔드 연동](#6-프론트엔드-연동)
7. [테스트 및 배포](#7-테스트-및-배포)

---

## 1. 환경 설정

### 1.1 Python 가상환경 설정

```bash
# 가상환경 생성
python -m venv venv

# 가상환경 활성화 (Windows)
venv\Scripts\activate

# 가상환경 활성화 (Linux/Mac)
source venv/bin/activate
```

### 1.2 Python 패키지 설치

**requirements.txt:**
```
# 데이터 처리
pandas==2.1.0
numpy==1.24.3

# 데이터베이스
sqlalchemy==2.0.20
psycopg2-binary==2.9.9

# 머신러닝
tensorflow==2.13.0
scikit-learn==1.3.0

# 백엔드
fastapi==0.103.0
uvicorn==0.23.2
python-dotenv==1.0.0

# 데이터 수집
requests==2.31.0
beautifulsoup4==4.12.2
selenium==4.11.2

# 시각화
matplotlib==3.7.2
seaborn==0.12.2

# 테스트
pytest==7.4.0
pytest-cov==4.1.0
```

```bash
pip install -r requirements.txt
```

### 1.3 데이터베이스 설정

PostgreSQL 설치 및 데이터베이스 생성:

```bash
# PostgreSQL 설치 (Ubuntu)
sudo apt-get install postgresql postgresql-contrib

# PostgreSQL 시작
sudo service postgresql start

# 데이터베이스 생성
sudo -u postgres createdb kbo_betting_db

# 사용자 생성
sudo -u postgres psql
CREATE USER kbo_user WITH PASSWORD 'your_password';
GRANT ALL PRIVILEGES ON DATABASE kbo_betting_db TO kbo_user;
\q
```

---

## 2. 데이터베이스 구축

### 2.1 스키마 생성

```bash
# SQL 스크립트 실행
psql -U kbo_user -d kbo_betting_db -f docs/database_schema.sql
```

또는 Python으로 실행:

```python
# scripts/setup_database.py
from sqlalchemy import create_engine
import psycopg2

# 데이터베이스 연결
engine = create_engine('postgresql://kbo_user:your_password@localhost/kbo_betting_db')

# SQL 파일 읽기 및 실행
with open('docs/database_schema.sql', 'r', encoding='utf-8') as f:
    sql = f.read()
    
with engine.connect() as conn:
    conn.execute(sql)
    conn.commit()

print("데이터베이스 스키마 생성 완료!")
```

### 2.2 초기 데이터 입력

```python
# scripts/insert_initial_data.py
from sqlalchemy import create_engine
import pandas as pd

engine = create_engine('postgresql://kbo_user:your_password@localhost/kbo_betting_db')

# 팀 정보 입력
teams_data = {
    'name': ['LG 트윈스', '두산 베어스', '삼성 라이온즈', ...],
    'abbreviation': ['LG', '두산', '삼성', ...],
    'stadium_name': ['잠실야구장', '잠실야구장', '대구삼성라이온즈파크', ...],
    'founded_year': [1982, 1982, 1982, ...]
}

df_teams = pd.DataFrame(teams_data)
df_teams.to_sql('teams', engine, if_exists='append', index=False)
```

---

## 3. 데이터 수집

### 3.1 경기 데이터 수집

**scripts/data_collection/kbo_match_scraper.py:**

```python
import requests
from bs4 import BeautifulSoup
import pandas as pd
from sqlalchemy import create_engine
import time

def scrape_kbo_matches(season, start_date, end_date):
    """
    KBO 경기 결과 수집
    """
    matches = []
    
    # KBO 공식 사이트 크롤링 (예시)
    url = f"https://www.koreabaseball.com/Schedule/Schedule.aspx?leId=1&srId=0&season={season}"
    
    response = requests.get(url)
    soup = BeautifulSoup(response.content, 'html.parser')
    
    # 경기 데이터 파싱
    # ... (실제 크롤링 로직 구현)
    
    return matches

def save_to_database(matches):
    """
    수집한 경기 데이터를 DB에 저장
    """
    engine = create_engine('postgresql://kbo_user:your_password@localhost/kbo_betting_db')
    
    df = pd.DataFrame(matches)
    df.to_sql('matches', engine, if_exists='append', index=False)

if __name__ == '__main__':
    # 최근 3년간 데이터 수집
    for year in range(2021, 2024):
        matches = scrape_kbo_matches(year, f'{year}-01-01', f'{year}-12-31')
        save_to_database(matches)
        time.sleep(1)  # API 호출 제한
```

### 3.2 배당률 데이터 수집

**scripts/data_collection/odds_scraper.py:**

```python
def scrape_sportstoto_odds():
    """
    스포츠토토 배당률 수집
    """
    # 스포츠토토 사이트 크롤링
    # ... (실제 구현)
    pass
```

### 3.3 자동화 스케줄링

**scripts/scheduler.py:**

```python
import schedule
import time

def daily_data_collection():
    """
    일일 데이터 수집 작업
    """
    # 새로운 경기 일정 수집
    # 배당률 업데이트
    pass

# 매일 오전 9시 실행
schedule.every().day.at("09:00").do(daily_data_collection)

# 매 시간마다 배당률 업데이트
schedule.every().hour.do(update_odds)

while True:
    schedule.run_pending()
    time.sleep(60)
```

---

## 4. ML 모델 개발

### 4.1 데이터 전처리

**scripts/preprocessing/feature_extraction.py:**

```python
import pandas as pd
import numpy as np

def extract_features():
    """
    경기 데이터에서 특성 추출
    """
    # DB에서 경기 데이터 로드
    matches = pd.read_sql('SELECT * FROM matches WHERE is_completed = TRUE', engine)
    
    # 팀별 특성 추출
    features = []
    for _, match in matches.iterrows():
        home_features = extract_team_features(matches, match['home_team_id'])
        away_features = extract_team_features(matches, match['away_team_id'])
        
        feature_vector = {
            'home_win_rate': home_features['win_rate'],
            'home_avg_score': home_features['avg_score'],
            'away_win_rate': away_features['win_rate'],
            'away_avg_score': away_features['avg_score'],
            'is_home': 1,
            'target': 1 if match['winner'] == 'home' else 0
        }
        features.append(feature_vector)
    
    return pd.DataFrame(features)
```

### 4.2 모델 학습

**scripts/training/train_lstm.py:**

```python
from tensorflow import keras
from sklearn.model_selection import train_test_split

def train_lstm_model():
    """
    LSTM 모델 학습
    """
    # 데이터 로드
    X, y = prepare_sequence_data(matches)
    
    # Train/Validation Split
    X_train, X_val, y_train, y_val = train_test_split(
        X, y, test_size=0.2, random_state=42
    )
    
    # 모델 생성
    model = build_lstm_model()
    
    # 학습
    history = model.fit(
        X_train, y_train,
        validation_data=(X_val, y_val),
        epochs=50,
        batch_size=32,
        callbacks=[
            keras.callbacks.EarlyStopping(patience=5),
            keras.callbacks.ModelCheckpoint('models/lstm_best.h5', save_best_only=True)
        ]
    )
    
    # 모델 저장
    model.save('models/lstm_model.h5')
    print("모델 학습 완료!")

if __name__ == '__main__':
    train_lstm_model()
```

### 4.3 모델 평가

**scripts/evaluation/evaluate_model.py:**

```python
from sklearn.metrics import accuracy_score, log_loss, brier_score_loss

def evaluate_model(model, X_test, y_test):
    """
    모델 성능 평가
    """
    predictions = model.predict(X_test)
    
    metrics = {
        'accuracy': accuracy_score(y_test, predictions > 0.5),
        'log_loss': log_loss(y_test, predictions),
        'brier_score': brier_score_loss(y_test, predictions),
    }
    
    # 결과를 DB에 저장
    save_performance_metrics('lstm_v1', metrics)
    
    return metrics
```

---

## 5. 백엔드 API 개발

### 5.1 FastAPI 애플리케이션 구조

**app/main.py:**

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.api import matches, predictions, betting, performance

app = FastAPI(title="KBO Betting AI API")

# CORS 설정
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 라우터 등록
app.include_router(matches.router, prefix="/api/matches", tags=["matches"])
app.include_router(predictions.router, prefix="/api/predictions", tags=["predictions"])
app.include_router(betting.router, prefix="/api/betting", tags=["betting"])
app.include_router(performance.router, prefix="/api/performance", tags=["performance"])

@app.get("/")
async def root():
    return {"message": "KBO Betting AI API"}
```

### 5.2 API 엔드포인트 구현

**app/api/predictions.py:**

```python
from fastapi import APIRouter, HTTPException
from app.services.prediction_service import PredictionService

router = APIRouter()
prediction_service = PredictionService()

@router.post("/{match_id}")
async def generate_prediction(match_id: int, model_name: str):
    """
    경기 예측 생성
    """
    try:
        prediction = prediction_service.generate_prediction(match_id, model_name)
        return prediction
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{match_id}")
async def get_prediction(match_id: int, model_name: str):
    """
    예측 결과 조회
    """
    prediction = prediction_service.get_prediction(match_id, model_name)
    if not prediction:
        raise HTTPException(status_code=404, detail="예측 결과를 찾을 수 없습니다")
    return prediction
```

### 5.3 서비스 레이어 구현

**app/services/prediction_service.py:**

```python
from app.models.database import get_db
from app.models.ml_models import load_model
import numpy as np

class PredictionService:
    def __init__(self):
        self.models = {}
    
    def generate_prediction(self, match_id: int, model_name: str):
        """
        예측 생성
        """
        # 모델 로드
        if model_name not in self.models:
            self.models[model_name] = load_model(model_name)
        
        model = self.models[model_name]
        
        # 경기 데이터 로드
        match_data = get_match_data(match_id)
        
        # 특성 추출
        features = extract_features(match_data)
        
        # 예측
        prediction_prob = model.predict(features)
        
        # DB에 저장
        save_prediction_to_db(match_id, model_name, prediction_prob)
        
        return {
            'match_id': match_id,
            'model_name': model_name,
            'home_win_probability': float(prediction_prob[0]),
            'away_win_probability': float(1 - prediction_prob[0])
        }
```

---

## 6. 프론트엔드 연동

### 6.1 API 서비스 생성

**frontend/src/services/api.js:**

```javascript
import axios from 'axios';

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

export const matchesAPI = {
  getMatches: (startDate, endDate) =>
    api.get('/api/matches', { params: { start_date: startDate, end_date: endDate } }),
  
  getMatch: (matchId) =>
    api.get(`/api/matches/${matchId}`),
};

export const predictionsAPI = {
  generatePrediction: (matchId, modelName) =>
    api.post(`/api/predictions/${matchId}`, { model_name: modelName }),
  
  getPrediction: (matchId, modelName) =>
    api.get(`/api/predictions/${matchId}`, { params: { model_name: modelName } }),
};

export const bettingAPI = {
  getBettingResults: (model, period) =>
    api.get('/api/betting/results', { params: { model, period } }),
};

export const performanceAPI = {
  getPerformance: (modelName, period) =>
    api.get('/api/performance', { params: { model_name: modelName, period } }),
};
```

### 6.2 컴포넌트 연동

**frontend/src/components/Dashboard/ProfitAnalysis.js 수정:**

```javascript
import { performanceAPI } from '../../services/api';
import { useState, useEffect } from 'react';

function ProfitAnalysis() {
  const [performanceData, setPerformanceData] = useState(null);

  useEffect(() => {
    loadPerformanceData();
  }, []);

  const loadPerformanceData = async () => {
    try {
      const response = await performanceAPI.getPerformance('lstm_v1', '30일');
      setPerformanceData(response.data);
    } catch (error) {
      console.error('성능 데이터 로드 실패:', error);
    }
  };

  // ... 나머지 코드
}
```

---

## 7. 테스트 및 배포

### 7.1 단위 테스트

**tests/test_models.py:**

```python
import pytest
from app.models.ml_models import LSTM_Model

def test_lstm_prediction():
    model = LSTM_Model()
    test_data = np.random.randn(1, 10, 20)
    prediction = model.predict(test_data)
    
    assert prediction.shape == (1, 1)
    assert 0 <= prediction[0] <= 1
```

### 7.2 API 테스트

```bash
# uvicorn으로 서버 실행
uvicorn app.main:app --reload

# API 테스트
curl http://localhost:8000/api/predictions/1?model_name=lstm_v1
```

### 7.3 배포

**Docker 설정:**

```dockerfile
# Dockerfile
FROM python:3.9

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**docker-compose.yml:**

```yaml
version: '3.8'

services:
  db:
    image: postgres:13
    environment:
      POSTGRES_DB: kbo_betting_db
      POSTGRES_USER: kbo_user
      POSTGRES_PASSWORD: your_password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  backend:
    build: .
    ports:
      - "8000:8000"
    depends_on:
      - db
    environment:
      DATABASE_URL: postgresql://kbo_user:your_password@db/kbo_betting_db

volumes:
  postgres_data:
```

---

## 8. 모니터링 및 유지보수

### 8.1 모델 성능 모니터링

- 주기적으로 모델 성능 지표 업데이트
- 예측 정확도 추이 모니터링
- 데이터 드리프트 감지

### 8.2 자동 재학습

- 월별 자동 재학습 스케줄 설정
- 성능 저하 시 자동 재학습 트리거

---

**이 가이드를 따라 단계별로 구현하세요!**


